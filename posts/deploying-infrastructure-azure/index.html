<!doctype html><html><head><title>Deploying Atlantis for Azure DevOps onto Kubernetes // Plex Engineering</title><meta charset=utf-8><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:title" content="Deploying Atlantis for Azure DevOps onto Kubernetes"><meta property="og:description" content="Blog posts written by engineers at Plex Systems"><meta property="og:type" content="website"><meta property="og:locale" content="en"><meta property="og:url" content="https://plexsystems.github.io/posts/deploying-infrastructure-azure/"><meta property="og:image" content="https://engineering.plex.com/images/plexsocial.png"><link rel="shortcut icon" href=/favicon.ico?><link href=https://plexsystems.github.io/webfonts/ptserif/main.css rel=stylesheet type=text/css><link href=https://plexsystems.github.io/webfonts/source-code-pro/main.css rel=stylesheet type=text/css><link href=https://plexsystems.github.io/webfonts/helvetica/main.css rel=stylesheet type=text/css><link rel=stylesheet href=https://plexsystems.github.io/css/style.css><link rel=stylesheet href=https://plexsystems.github.io/css/custom.css><meta name=generator content="Hugo 0.71.1"></head><body><div id=container><header id=header><div id=header-outer class=outer><div id=header-inner class=inner><div class=logo-display><a class=logo href=https://plexsystems.github.io/></a><a class=logo-text href=https://plexsystems.github.io/>Engineering</a></div><div class=icons-display><a href=//github.com/plexsystems><img class=github-img src=/images/github.png alt=github></a></div></div></header><section id=main class=outer><article class="article article-type-post" itemscope itemprop=blogPost><div class=article-inner><header class=article-header><h1 class=article-title itemprop=name>Deploying Atlantis for Azure DevOps onto Kubernetes</h1></header><div class=article-meta><img alt="John Reese" class=article-author-img src="https://avatars2.githubusercontent.com/jpreese?v=3&s=40">
<span class=article-author><a href=//github.com/jpreese>John Reese</a></span>
<img class=calendar-img src=/images/calendar.png alt=calendar>
<span class=article-date><time datetime=04-20-2020 itemprop=datePublished>April 5, 2020</time></span>
//
<span class=article-categories><a class=article-category-link href=https://plexsystems.github.io/categories/azure>azure</a>
<a class=article-category-link href=https://plexsystems.github.io/categories/infrastructure>infrastructure</a>
<a class=article-category-link href=https://plexsystems.github.io/categories/kubernetes>kubernetes</a>
<a class=article-category-link href=https://plexsystems.github.io/categories/terraform>terraform</a></span></div><div class=article-entry itemprop=articleBody><p><img src=/images/deploying-infrastructure-azure/featured.jpg><br><p>At Plex, our initial adoption of <a href=https://www.terraform.io/>Terraform</a> was relatively painless. There weren&rsquo;t many teams writing infrastructure as code, and most of the changes that were being deployed through Terraform were new pieces of infrastructure that didn&rsquo;t have any dependencies.</p><p>As the number of teams using Terraform and managing their own infrastructure grew, it became apparent that we needed to start putting some processes in place for a few reasons.</p><h2 id=collaboration-was-difficult>Collaboration was difficult</h2><p>In order for an engineer to verify their Terraform changes, they needed to be able to run <code>terraform plan</code> against live infrastructure. In most cases, this was done locally on their computer. While this approach made it easy for the engineer to get feedback, it presented other problems.</p><p>First, to successfully run a plan against the existing infrastructure, the engineer needed to have read access to all of the resources that they were making changes to. While this seemed reasonable, it became a problem of scale. Anyone who wanted to be an effective contributor to the code base needed read permissions in Azure. This quickly spiraled out of control and made managing access more difficult.</p><p>Secondly, at Plex we require multiple approvers for every pull request. This meant that not only did the engineer creating the pull request have to run a <code>terraform plan</code> against their changes, but the reviewer of the code as well. This typically meant that the result of a plan was pasted into the pull request so that everyone could see how each resource would be impacted.</p><h2 id=problems-with-different-terraform-clients>Problems with different Terraform clients</h2><p>Not all engineers have the same Terraform client installed on their computer. This can cause problems when working on the same backing Terraform state.</p><p>When executing a <code>terraform refresh</code> or <code>terraform apply</code> against the current state, the version of Terraform that was used is stored in the state file. Attempting to execute Terraform commands with an older Terraform client than what is listed in the state file will result in an error similar to the following:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>Terraform doesn&#39;t allow running any operations against a state
that was written by a future Terraform version. The state is
reporting it is written by Terraform &#39;0.12.0&#39;
</code></pre></div><p>It&rsquo;s important to note that newer Terraform clients can change the syntax of the state file and how the results should be interpreted. Unfortunately, older Terraform clients will not know how to process this newer information and will need to be updated.</p><p>This means that if an engineer has Terraform <code>0.12.1</code> on their machine and executes a <code>refresh</code> or <code>apply</code>, the state will be updated to include version <code>0.12.1</code> and everyone will need to upgrade their clients.</p><h2 id=plans-went-stale>Plans went stale</h2><p>Unfortunately, infrastructure can change at a moment&rsquo;s notice. Especially when multiple contributors are working on the same infrastructure. Consider the following scenario:</p><p>An engineer opens a pull request against a Terraform module and views the resulting plan. This plan highlights which resources will be created, destroyed, and/or updated. The plan looks good, but they decide to hold off on deploying the change because it&rsquo;s a Friday. Give that engineer a gold star!</p><p>Monday morning rolls around, and another engineer opens a pull request against the same module. Nothing seems out of the ordinary in the plan, so they apply the plan to production.</p><p>Now unfortunately for the first engineer in our scenario, their plan is no longer current.</p><p>At this point the original plan has lost most, if not all value. Worst yet, if the original developer is unaware of the newly introduced change, an apply to production could cause problems. Lots of problems.</p><h2 id=the-homegrown-solution>The homegrown solution</h2><p>To address these problems, we wrote two PowerShell scripts (one for plan and one for apply) that would be executed on our build agents in Azure. These were wired up as policy checks in the repository, allowing us to run them on-demand or automatically with Azure <a href="https://docs.microsoft.com/en-us/azure/devops/service-hooks/services/webhooks?view=azure-devops">webhooks</a>.</p><p>When a pull request was created, the plan script would execute <code>terraform plan</code> against the changes and output the results of the plan to the pull request comment thread. This enabled reviewers to see the actual changes that were being introduced, without having to run the plan locally themselves. Awesome! Our first problem was solved.</p><p>Then, if the plan looked good and the appropriate reviewers approved the change, another script would handle the <code>terraform apply</code> step.</p><p>To solve the issue of stale plans, we added a policy that for a <code>terraform apply</code> to be executed, an associated plan needed to be run at least 30 minutes prior. It wasn&rsquo;t ideal, but shortened the window of failure and gave us enough confidence that the original plan was still valid.</p><p>This approach worked well for us in the beginning, but as the amount of managed infrastructure, and the number of teams using the solution grew, we started noticing gaps.</p><p>Rather than continuing to invest in our homegrown solution, we set out to find an alternative. If the title of the blog didn&rsquo;t already give it away, that solution was Atlantis.</p><h2 id=atlantis>Atlantis</h2><p><a href=https://www.runatlantis.io/>Atlantis</a> is a pull request automation tool that makes it easier for teams to manage and deploy their infrastructure.</p><p>Conveniently, it addresses the problems that we have already discussed:</p><ul><li>Visual <code>plan</code> and <code>apply</code> results in the pull request? <em>Check.</em></li><li>Each repository can set the required version of Terraform? <em>Check.</em></li><li>State locking to guarantee that plans stay relevant? <em>Check.</em></li></ul><p>Best of all, not only does it run on Kubernetes, it&rsquo;s an <a href=https://github.com/runatlantis/atlantis>open source project</a>!</p><h3 id=how-it-works>How it works</h3><p>Atlantis is controlled by typing commands as comments on the pull request comment thread. Need to run <code>plan</code> against your pull request? Just comment on the pull request: <code>atlantis plan</code>. This will instruct Atlantis to get the plan for your changes and respond to the pull request with the result.</p><p>To get the plan, Atlantis will:</p><ol><li><p>Clone the repository to its data drive. If you&rsquo;re running Atlantis on Kubernetes, this will either be a local drive within the container (using a Deployment) or a Persistent Volume Claim (using a StatefulSet).</p></li><li><p>Lock the folder containing the changes and store the lock metadata to its data drive. This prevents plans from getting stale and prevents conflicts from multiple contributors.</p></li><li><p>Execute <code>terraform plan</code> against the folder containing the change.</p></li><li><p>Report the plan result as a comment in the pull request.</p></li></ol><p>This results in the following workflow:</p><figure><img src=/images/deploying-infrastructure-azure/atlantis_workflow.png></figure><p>With this approach, engineers no longer need to have access to the managed infrastructure. All plan and apply operations are handled within the pull request.</p><p>As a bonus, Atlantis also supports webhooks, which enable actions to be performed automatically, such as when a pull request is opened or the code within the pull request is modified.</p><h2 id=rolling-out-atlantis>Rolling out Atlantis</h2><p>One of the first decision points during our roll-out of Atlantis was: <em>How are we going to host this?</em>. Given that Atlantis runs inside of a Docker container, we had several options in front of us. Should we stand up an <a href=https://docs.microsoft.com/en-us/azure/container-instances/>Azure Container Instance</a>? Kubernetes? <em>Spolier alert, it&rsquo;s probably Kubernetes.</em></p><p>Regardless of the final home for Atlantis, there are some preliminary steps that we had to complete.</p><h3 id=1-create-the-atlantis-user>1. Create the Atlantis user</h3><p>Atlantis will need to use a user account that will be responsible for cloning the repositories and responding to pull requests. We decided to create a user named <code>atlantis</code>. <em>Completely original, I know.</em></p><p>We also created a Personal Access Token (PAT) for this user with the minimum scope possible:</p><ul><li><code>Code (Read & Write)</code></li><li><code>Code (Status)</code></li></ul><h3 id=2-configure-atlantis-for-terragrunt>2. Configure Atlantis for Terragrunt</h3><p>We use <a href=https://github.com/gruntwork-io/terragrunt>Terragrunt</a> in our infrastructure repositories to help keep our infrastructure codebases DRY. Unfortunately, Atlantis does not support Terragrunt workflows out of the box and only provides a default workflow which excutes basic Terraform commands.</p><p>However, Atlantis allows you to create your own workflows if you provide a <a href=https://www.runatlantis.io/docs/server-side-repo-config.html>server side repository configuration</a>. This enabled us to extend Atlantis and run <code>terragrunt</code> commands.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#66d9ef>repos</span>:
<span style=color:#75715e># The list of repositories Atlantis watches. Supports wildcards/*</span>
- <span style=color:#66d9ef>id</span>: dev.azure.com/org/project/first-repo

  <span style=color:#75715e># Only allow &#34;apply&#34; comments if the PR is approved and can be merged</span>
  <span style=color:#66d9ef>apply_requirements</span>: [approved, mergeable]
  <span style=color:#66d9ef>workflow</span>: terragrunt

<span style=color:#75715e># Instead of terraform commands, run these for plan and apply</span>
<span style=color:#66d9ef>workflows</span>:
  <span style=color:#66d9ef>terragrunt</span>:
    <span style=color:#66d9ef>plan</span>:
      <span style=color:#66d9ef>steps</span>:
      - <span style=color:#66d9ef>run</span>: terragrunt init -input=<span style=color:#66d9ef>false</span> -no-color
      - <span style=color:#66d9ef>run</span>: terragrunt plan -input=<span style=color:#66d9ef>false</span> -no-color -out $PLANFILE
    <span style=color:#66d9ef>apply</span>:
      <span style=color:#66d9ef>steps</span>:
      - <span style=color:#66d9ef>run</span>: terragrunt apply -input=<span style=color:#66d9ef>false</span> -no-color $PLANFILE
</code></pre></div><pre><code class=language-subtext data-lang=subtext>repository-config.yaml
</code></pre><h3 id=3-customize-the-atlantis-image>3. Customize the Atlantis image</h3><p>Plex <a href=https://en.wikipedia.org/wiki/Air_gap_(networking)>air gaps</a> its infrastructure pipelines, so it&rsquo;s not possible to download plugins on demand. Instead, we leverage Terraform&rsquo;s plugin cache and download the plugins ahead of time.</p><p>To accomplish this, we wrote our own custom <code>Dockerfile</code> that was based off of the original Atlantis image:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> golang:1.13 as builder</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> apt-get update <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  <span style=color:#f92672>&amp;&amp;</span> apt-get install unzip<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># Install terraform-bundle</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> git clone <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  --depth <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  --single-branch <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  --branch <span style=color:#e6db74>&#34;v0.12.0&#34;</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  https://github.com/hashicorp/terraform.git <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  $GOPATH/src/github.com/hashicorp/terraform<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> cd $GOPATH/src/github.com/hashicorp/terraform <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  <span style=color:#f92672>&amp;&amp;</span> go install ./tools/terraform-bundle<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># Download plugins</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> terraform-bundle.hcl .<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> terraform-bundle package -os<span style=color:#f92672>=</span>linux -arch<span style=color:#f92672>=</span>amd64 terraform-bundle.hcl<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> mkdir /go/tmp <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  <span style=color:#f92672>&amp;&amp;</span> unzip /go/terraform_*-bundle*_linux_amd64.zip -d /go/tmp<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> runatlantis/atlantis:v0.11.1</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ENV</span> TF_IN_AUTOMATION<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;true&#34;</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ENV</span> TF_CLI_ARGS_init<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;-plugin-dir=/home/atlantis/.atlantis/plugin-cache&#34;</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># Install Azure CLI</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ARG</span> AZURE_CLI_VERSION<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;2.0.74&#34;</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> apk add py-pip <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  <span style=color:#f92672>&amp;&amp;</span> apk add --virtual<span style=color:#f92672>=</span>build gcc libffi-dev musl-dev openssl-dev python-dev make<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> pip --no-cache-dir install azure-cli<span style=color:#f92672>==</span><span style=color:#e6db74>${</span>AZURE_CLI_VERSION<span style=color:#e6db74>}</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># Install Terragrunt</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ARG</span> TERRAGRUNT_VERSION<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;v0.23.2&#34;</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> curl -L -o /usr/local/bin/terragrunt https://github.com/gruntwork-io/terragrunt/releases/download/<span style=color:#e6db74>${</span>TERRAGRUNT_VERSION<span style=color:#e6db74>}</span>/terragrunt_linux_amd64 <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  <span style=color:#f92672>&amp;&amp;</span> chmod +x /usr/local/bin/terragrunt<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># Copy plugins</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> .terraformrc /root/.terraformrc<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> --chown<span style=color:#f92672>=</span>atlantis:atlantis --from<span style=color:#f92672>=</span>builder /go/tmp /home/atlantis/.atlantis/plugin-cache<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> mv /home/atlantis/.atlantis/plugin-cache/terraform /usr/local/bin/terraform<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># Configure git</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> .gitconfig /home/atlantis/.gitconfig<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> azure-devops-helper.sh /home/atlantis/azure-devops-helper.sh<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># Copy server-side repository config</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> repository-config.yaml /home/atlantis/repository-config.yaml<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>CMD</span> [<span style=color:#e6db74>&#34;server&#34;</span>, <span style=color:#e6db74>&#34;--repo-config=/home/atlantis/repository-config.yaml&#34;</span>]<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>LABEL</span> org.opencontainers.image.title<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Atlantis Environment&#34;</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>LABEL</span> org.opencontainers.image.description<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;An environment to support executing Terragrunt operations with Atlantis&#34;</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>LABEL</span> binary.atlantis.version<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;v0.11.1&#34;</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>LABEL</span> binary.terragrunt.version<span style=color:#f92672>=</span><span style=color:#e6db74>${</span>TERRAGRUNT_VERSION<span style=color:#e6db74>}</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>LABEL</span> binary.azure-cli.version<span style=color:#f92672>=</span><span style=color:#e6db74>${</span>AZURE_CLI_VERSION<span style=color:#e6db74>}</span><span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><pre><code class=language-subtext data-lang=subtext>dockerfile
</code></pre><p>Our <code>Dockerfile</code> not only contains Atlantis, but:</p><ul><li>Terragrunt for DRY infrastructure code.</li><li>The Azure CLI to be able to provision and manage Azure resources.</li><li><a href=https://github.com/hashicorp/terraform/tree/master/tools/terraform-bundle>Terraform Bundle</a> to explicitly configure which plugins are pre-installed.</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hcl data-lang=hcl><span style=color:#75715e># The version of Terraform to include with the bundle.
</span><span style=color:#75715e></span><span style=color:#66d9ef>terraform</span> {
  version <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;0.12.21&#34;</span>
}<span style=color:#75715e>
</span><span style=color:#75715e>
</span><span style=color:#75715e># The providers to pre-download and include in the Atlantis image.
</span><span style=color:#75715e></span><span style=color:#66d9ef>providers</span> {
  azurerm     <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#34;~&gt; 2.0.0&#34;</span>]
  azuread     <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#34;~&gt; 0.7.0&#34;</span>]
  random      <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#34;~&gt; 2.2.0&#34;</span>]
  local       <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#34;~&gt; 1.4.0&#34;</span>]
}
</code></pre></div><pre><code class=language-subtext data-lang=subtext>terraform-bundle.hcl
</code></pre><p>.. as well as small helper script to assist with authorization to Azure DevOps.</p><p>While Atlantis <em>does</em> have a <code>--write-git-creds</code> flag which will write out a <code>.git-credentials</code> file and configure the <code>git</code> client within the Docker image. We found that at the time of our implementation (and writing this post), it always assumed an <code>ssh</code> connection.</p><p>In other words if, like us, you reference your Terraform modules via <code>https</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hcl data-lang=hcl><span style=color:#66d9ef>module</span> <span style=color:#e6db74>&#34;foo&#34;</span> {
  source <span style=color:#f92672>=</span> &#34;git::https://org@dev.azure.com/org/project/_git/modules//foo?ref<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>1</span>.<span style=color:#ae81ff>0</span><span style=color:#960050;background-color:#1e0010>&#34;</span>
}
</code></pre></div><p>Atlantis won&rsquo;t be able to pull your private module repositories within Azure DevOps.</p><p>To work around this, we implemented a <a href=https://git-scm.com/docs/gitcredentials>git credential helper</a> that sets the git username and password to the credentials that have already passed into the environment.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#f92672>[</span>credential <span style=color:#e6db74>&#34;https://dev.azure.com&#34;</span><span style=color:#f92672>]</span>
	helper <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;/bin/sh /home/atlantis/azure-devops-helper.sh&#34;</span>
</code></pre></div><pre><code class=language-subtext data-lang=subtext>.gitconfig
</code></pre><p></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e>#!/bin/sh 
</span><span style=color:#75715e></span>
<span style=color:#75715e># These values are already provided to the container from</span>
<span style=color:#75715e># the Kubernetes manifest.</span>
echo username<span style=color:#f92672>=</span>$ATLANTIS_AZUREDEVOPS_WEBHOOK_USER
echo password<span style=color:#f92672>=</span>$ATLANTIS_AZUREDEVOPS_TOKEN
</code></pre></div><pre><code class=language-subtext data-lang=subtext>azure-devops-helper.sh
</code></pre><p>While the above <code>Dockerfile</code> may be more than you need, at a minimum you&rsquo;ll need the Azure CLI if you intend on managing Azure resources.</p><h3 id=4-apply-the-manifests-to-kubernetes>4. Apply the manifests to Kubernetes</h3><p>Many of our workloads at Plex already run on Kubernetes, so it seemed like the most reasonable choice for Atlantis as well. Better yet, the Atlantis team already provides the Kubernetes manifests, as well as examples on how to configure them. Both a Deployment and StatefulSet example are included <a href=https://www.runatlantis.io/docs/deployment.html#statefulset-manifest>here</a>.</p><p>We ended up choosing the StatefulSet approach, but your requirements may be different. The biggest factor to consider when choosing between the two approaches is that a Deployment won&rsquo;t persist the locks on your repositories if the pod is restarted, whereas a StatefulSet will. This is because Atlantis stores all of its data (e.g. locks, plugins) in its <code>data directory</code>. When using a Deployment resource, this will just be a folder within the container, which has no guarantees to persist if the pod is restarted. On the other hand, a StatefulSet will use a Persistent Volume Claim which allowis the locks to persist, even through a restart.</p><p>Regardless of your choice, all that needs to be done is to find the <code>Azure DevOps Config</code> section in the provided example manifests and replace the placeholder values with the credentials that were created in the previous step.</p><h3 id=5-configure-the-webhooks>5. Configure the webhooks</h3><p>At this point, we had:</p><ul><li>A user to clone repositories and comment on pull requests with the proper access.</li><li>A Dockerfile with the tools needed to complete our workflows.</li><li>The Atlantis manifests applied to our Kubernetes cluster.</li></ul><p>The last major step in getting up and running with Atlantis, was to add the webhooks that would respond to events within our repository.</p><p>Similar to the Kubernetes manifests, Atlantis provides great <a href=https://www.runatlantis.io/docs/configuring-webhooks.html#azure-devops>documentation</a> on how to configure these for Azure DevOps.</p><p>We just followed the steps, tested the connection, and began using Atlantis to review and deploy our infrastructure changes!</p><h2 id=returning-to-the-surface>Returning to the surface</h2><p>Our journey to Atlantis was long, but we intend to vacation here for quite a while.</p><p>Teams can now create custom infrastructure workflows that make sense for them, and we now have a central authority for all infrastructure changes. Better yet, it allowed us to retire our legacy workflows, and adopt an open source solution with a great community behind it.</p><p>We would like to give a special thanks to <a href=https://twitter.com/mcdafydd>@mcdafydd</a> for adding the Azure DevOps integration to Atlantis. As we continue to use Atlantis, we hope to contribute back to the project and make managing infrastructure with Atlantis even better.</p></p></div></div><nav id=article-nav><a href=/posts/kubernetes-policy-conftest/ id=article-nav-newer class=article-nav-link-wrap><div class=article-nav-title><span>&lt;</span>&nbsp;
Accelerated Feedback Loops when Developing for Kubernetes with Conftest</div></a></nav></article><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"plexengineering"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></section></div><br><footer><div class=outer><div id=footer-note>All blog posts are written by engineers at Plex Systems. Our goal is to share our experiences in order to
promote openness and collaboration within the technical community.</div><div id=copyright>&copy; 2020 Plex Systems</div></div><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-170945889-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/tomorrow-night.min.css integrity="sha256-2wL88NKUqvJi/ExflDzkzUumjUM73mcK2gBvBBeLvTk=" crossorigin=anonymous><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js integrity="sha256-KbfTjB0WZ8vvXngdpJGY3Yp3xKk+tttbqClO11anCIU=" crossorigin=anonymous></script><script>hljs.initHighlightingOnLoad();</script><script></script></footer></body></html>