<!doctype html><html><head><title>Introducing Sinker: A tool to sync container images from one registry to another // Plex Engineering</title><meta charset=utf-8><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:title" content="Introducing Sinker: A tool to sync container images from one registry to another"><meta property="og:description" content="Blog posts written by engineers at Plex Systems"><meta property="og:type" content="website"><meta property="og:locale" content="en"><meta property="og:url" content="https://plexsystems.github.io/posts/introducing-sinker/"><meta property="og:image" content="https://engineering.plex.com/images/plexsocial.png"><link rel="shortcut icon" href=/favicon.ico?><link href=https://plexsystems.github.io/webfonts/ptserif/main.css rel=stylesheet type=text/css><link href=https://plexsystems.github.io/webfonts/source-code-pro/main.css rel=stylesheet type=text/css><link href=https://plexsystems.github.io/webfonts/helvetica/main.css rel=stylesheet type=text/css><link rel=stylesheet href=https://plexsystems.github.io/css/style.css><link rel=stylesheet href=https://plexsystems.github.io/css/custom.css><meta name=generator content="Hugo 0.71.1"></head><body><div id=container><header id=header><div id=header-outer class=outer><div id=header-inner class=inner><div class=logo-display><a class=logo href=https://plexsystems.github.io/></a><a class=logo-text href=https://plexsystems.github.io/>Engineering</a></div><div class=icons-display><a href=//github.com/plexsystems><img class=github-img src=/images/github.png alt=github></a></div></div></header><section id=main class=outer><article class="article article-type-post" itemscope itemprop=blogPost><div class=article-inner><header class=article-header><h1 class=article-title itemprop=name>Introducing Sinker: A tool to sync container images from one registry to another</h1></header><div class=article-meta><img alt="John Reese" class=article-author-img src="https://avatars2.githubusercontent.com/jpreese?v=3&s=40">
<span class=article-author><a href=//github.com/jpreese>John Reese</a></span>
<img class=calendar-img src=/images/calendar.png alt=calendar>
<span class=article-date><time datetime=07-20-2020 itemprop=datePublished>July 19, 2020</time></span>
//
<span class=article-categories><a class=article-category-link href=https://plexsystems.github.io/categories/containers>containers</a>
<a class=article-category-link href=https://plexsystems.github.io/categories/kubernetes>kubernetes</a>
<a class=article-category-link href=https://plexsystems.github.io/categories/open-source>open source</a></span></div><div class=article-entry itemprop=articleBody><p><img src=/images/introducing-sinker/featured.png><br><p>At Plex, all container images in our environments are sourced from our internal container registries. While this gives us greater control over which images can and cannot be used in our environments, it poses a bigger problem. How can we leverage container images that are managed in the public cloud?</p><p>A common solution to this problem is to sync the public container image to your organization&rsquo;s private registry by pulling down the image and then pushing it to your internal registry. However, this can be tedious for each public image that you intend to use. Furthermore, the origin of the original image is not always obvious, so updating to a newer version could result in a scavenger hunt to track down the original registry.</p><p>Our solution to these problems, as well as others around container image management, was to build <a href=https://github.com/plexsystems/sinker>Sinker</a>.</p><h2 id=introducing-sinker>Introducing Sinker</h2><p>Sinker is an open-source tool that not only pushes public images to an internal registry but also keeps a manifest of the images that are being used in each repository.</p><p>Consider the scenario where your team wants to be able to deploy the <a href=https://github.com/coreos/prometheus-operator>prometheus-operator</a>. To deploy the operator, three images are required: the operator itself, the config reloader for the operator, and a ConfigMap reloader.</p><p>Each of these images are not only tagged individually but are also sourced from different registries. Without any record of what image is in use and where the image came from, the upgrade story becomes difficult.</p><h3 id=the-image-manifest>The Image Manifest</h3><p>The image manifest is a <code>.yaml</code> file that is used by Sinker to perform all of its operations such as pulling and pushing images. The manifest for the prometheus operator would look like the following:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#66d9ef>target</span>:
  <span style=color:#66d9ef>host</span>: organization.com
  <span style=color:#66d9ef>repository</span>: team
<span style=color:#66d9ef>sources</span>:
- <span style=color:#66d9ef>repository</span>: coreos/prometheus-operator
  <span style=color:#66d9ef>host</span>: quay.io
  <span style=color:#66d9ef>tag</span>: v0<span style=color:#ae81ff>.40.0</span>
- <span style=color:#66d9ef>repository</span>: coreos/prometheus-config-reloader
  <span style=color:#66d9ef>host</span>: quay.io
  <span style=color:#66d9ef>tag</span>: v0<span style=color:#ae81ff>.40.0</span>
- <span style=color:#66d9ef>repository</span>: jimmidyson/configmap-reload
  <span style=color:#66d9ef>tag</span>: v0<span style=color:#ae81ff>.4.0</span>
</code></pre></div><pre><code class=language-subtext data-lang=subtext>.images.yaml - an example image manifest
</code></pre><p>The <code>sources</code> section defines all of the container images that should be pushed to the <code>target</code> registry. For example, the <code>prometheus-operator</code> image would be pushed to <code>organization.com/team/coreos/prometheus-operator</code> and tagged with <code>v0.40.0</code>.</p><p>With the introduction of the image manifest, there is now a defined desired state configuration for the target registry. The manifest could be added to each repository that needs to manage images or a central repository that defines which images are available to the entire organization.</p><h2 id=using-sinker-at-plex>Using Sinker at Plex</h2><p>We implemented Sinker to solve not only the problem of syncing public container images to our private registry but also to automatically detect which images are in use by our Kubernetes clusters.</p><p>Sinker&rsquo;s <code>create</code> command can optionally take a single <code>.yaml</code> file or directory that contains Kubernetes resources, and generate an image manifest with all of the found container images. Container images that are not only in the <code>image</code> field, but also images that are present inside of container arguments and some CRDs.</p><p>If we were to run the <code>create</code> command on the <code>bundle.yaml</code> produced by the prometheus-operator project, we would automatically create a familiar-looking manifest.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ sinker create bundle.yaml --target containers.plex.com/kubernetes
</code></pre></div><pre><code class=language-subtext data-lang=subtext>terminal
</code></pre><p>Result:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#66d9ef>target</span>:
  <span style=color:#66d9ef>host</span>: containers.plex.com
  <span style=color:#66d9ef>repository</span>: kubernetes
<span style=color:#66d9ef>sources</span>:
- <span style=color:#66d9ef>repository</span>: coreos/prometheus-operator
  <span style=color:#66d9ef>host</span>: quay.io
  <span style=color:#66d9ef>tag</span>: v0<span style=color:#ae81ff>.40.0</span>
- <span style=color:#66d9ef>repository</span>: coreos/prometheus-config-reloader
  <span style=color:#66d9ef>host</span>: quay.io
  <span style=color:#66d9ef>tag</span>: v0<span style=color:#ae81ff>.40.0</span>
- <span style=color:#66d9ef>repository</span>: jimmidyson/configmap-reload
  <span style=color:#66d9ef>tag</span>: v0<span style=color:#ae81ff>.4.0</span>
</code></pre></div><pre><code class=language-subtext data-lang=subtext>.images.yaml
</code></pre><p>Using the <code>update</code> command will then update the image manifest when the Kubernetes resources are modified. Automatically updating the manifest allows our engineers to only worry about making changes to their resources, and not adding, removing, or updating version definitions in two places. Automatic manifest updates also reduces human error because the <code>update</code> command is executed against the same manifests that will be deployed to the cluster.</p><p>When it comes to the local testing of Kubernetes deployments, most of our engineering teams leverage <a href=https://github.com/kubernetes-sigs/kind>Kind</a>. For Kind to be able to run container images that require authentication (which is usually the case for private registries), the image needs to be pre-loaded into the cluster.</p><p>To load all of the images into Kind, we can use Sinker&rsquo;s <code>pull</code> command. The <code>pull</code> command downloads all of the <code>target</code> images found in the image manifest onto the host machine.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ sinker pull target
INFO<span style=color:#f92672>[</span>0000<span style=color:#f92672>]</span> Finding images that need to be pulled ...
INFO<span style=color:#f92672>[</span>0000<span style=color:#f92672>]</span> Pulling containers.plex.com/coreos/prometheus-operator:v0.40.0
INFO<span style=color:#f92672>[</span>0012<span style=color:#f92672>]</span> Pulling containers.plex.com/coreos/coreos/prometheus-config-reloader:v0.40.0
INFO<span style=color:#f92672>[</span>0019<span style=color:#f92672>]</span> Pulling containers.plex.com/jimmidyson/configmap-reload:v0.4.0
INFO<span style=color:#f92672>[</span>0019<span style=color:#f92672>]</span> All images have been pulled!  
</code></pre></div><pre><code class=language-subtext data-lang=subtext>terminal
</code></pre><p>With the images pulled down onto the local machine, we can then use Sinker&rsquo;s <code>list</code> command to output a list of the target images and load them into Kind.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#66d9ef>for</span> i in <span style=color:#e6db74>`</span>sinker list target<span style=color:#e6db74>`</span>; <span style=color:#66d9ef>do</span>
  kind load docker-image <span style=color:#e6db74>${</span>i<span style=color:#e6db74>}</span> --name $CLUSTER_NAME
<span style=color:#66d9ef>done</span>
</code></pre></div><pre><code class=language-subtext data-lang=subtext>bash
</code></pre><h3 id=our-process-for-adding-and-updating-new-images>Our process for adding and updating new images</h3><p>One of the best use cases we&rsquo;ve found for Sinker is to incorporate it into a dedicated pipeline for updating and adding new images to our internal container registry. Moving the process of container image management into a pipeline ensures that every image present in the internal registry has been accepted for use.</p><p>When an engineer needs to add or update a container image, the pull request should include the image manifest. During the review process, it&rsquo;s easy to see which image the engineer wants to add to the registry. If the source host is untrusted, or if it&rsquo;s a beta release, there might need to be a broader discussion during the review process.</p><p>If the pull request is approved, the pipeline will first pull down all of the images present in the manifest. Immediately after pulling the images, we run a security vulnerability scan against all of the images.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#66d9ef>while</span> read -r dockerImage;
<span style=color:#66d9ef>do</span>
  twistcli images scan $dockerImage
  VIOLATION<span style=color:#f92672>=</span>$?
  <span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> $VIOLATION !<span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
    FOUND_VIOLATION<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>
  <span style=color:#66d9ef>fi</span>
<span style=color:#66d9ef>done</span> &lt; <span style=color:#e6db74>`</span>sinker list source<span style=color:#e6db74>`</span>
exit $FOUND_VIOLATION
</code></pre></div><pre><code class=language-subtext data-lang=subtext>bash
</code></pre><p>We list the <em>source</em> images here because we want to validate whether or not the image has any known vulnerabilities that exceed our comfort level <em>before</em> they are sync&rsquo;d and approved for use in our internal registry. If the image exceeds our threshold, the pipeline will fail the build, and the image will not be added to the internal registry.</p><p>After the vulnerability scan is complete and passes all of our thresholds, we then <a href=https://docs.microsoft.com/en-us/azure/container-registry/container-registry-image-lock>lock</a> all of the newly pushed images to ensure that they cannot be overwritten or deleted.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#66d9ef>while</span> read -r dockerImage;
<span style=color:#66d9ef>do</span>
  az acr repository update --name containers --image $dockerImage <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    --write-enabled false <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    --delete-enabled false
<span style=color:#66d9ef>done</span> &lt; <span style=color:#e6db74>`</span>sinker list target<span style=color:#e6db74>`</span>
</code></pre></div><pre><code class=language-subtext data-lang=subtext>bash
</code></pre><p>This pipeline guarantees that every image that our engineers use has already been pre-scanned for vulnerabilities. Additionally, there is no risk of the image being accidentally deleted or overwritten, thanks to Azure&rsquo;s image locking mechanisms.</p><h2 id=whats-next>What&rsquo;s next</h2><p>Sinker has solved several problems at Plex, but these problems are not unique to us! We open-sourced Sinker to help other organizations solve similar problems when working with syncing container images. If you&rsquo;re interested in trying Sinker for yourself, it can be downloaded from our <a href=https://github.com/plexsystems/sinker/releases>releases</a> page on GitHub.</p><p>We have some features in mind for future releases but are always looking for additional use cases to support the broader community. If you have a use case that isn&rsquo;t supported yet, add an issue to the repository. We&rsquo;d love to hear from you!</p></p></div></div><nav id=article-nav><a href=/posts/container-structure-test/ id=article-nav-older class=article-nav-link-wrap><div class=article-nav-title>Testing Containers with Container Structure Test&nbsp;<span>></span></div></a></nav></article><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"plexengineering"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></section></div><br><footer><div class=outer><div id=footer-note>All blog posts are written by engineers at Plex Systems. Our goal is to share our experiences in order to
promote openness and collaboration within the technical community.</div><div id=copyright>&copy; 2020 Plex Systems</div></div><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-170945889-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/tomorrow-night.min.css integrity="sha256-2wL88NKUqvJi/ExflDzkzUumjUM73mcK2gBvBBeLvTk=" crossorigin=anonymous><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js integrity="sha256-KbfTjB0WZ8vvXngdpJGY3Yp3xKk+tttbqClO11anCIU=" crossorigin=anonymous></script><script>hljs.initHighlightingOnLoad();</script><script></script></footer></body></html>